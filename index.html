<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebRTC P2P Demo ‚Äî Manual Signaling (No Backend)</title>
<style>
  :root{
    --bg:#0f1724; --card:#0b1220; --accent:#6ee7b7; --muted:#94a3b8; --danger:#fb7185;
    --glass: rgba(255,255,255,0.02);
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{margin:0; min-height:100vh; background:linear-gradient(180deg,#071029 0%, #081826 100%); color:#e6eef6; padding:18px; display:flex; gap:18px; align-items:flex-start; justify-content:center;}
  .wrap{max-width:1100px; width:100%; display:grid; grid-template-columns: 420px 1fr; gap:18px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:14px; border-radius:12px; box-shadow: 0 6px 18px rgba(2,6,23,0.6);}
  h1{margin:0 0 6px 0; font-size:18px;}
  p.small{margin:0 0 12px 0; color:var(--muted); font-size:13px;}
  video{width:100%; height:210px; background:#000; border-radius:8px; object-fit:cover; display:block;}
  .controls{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;}
  button, select, textarea, input{font-size:14px;}
  button{background:linear-gradient(90deg,var(--accent),#4fd1c5); color:#052024; border:none; padding:8px 10px; border-radius:8px; cursor:pointer; box-shadow: 0 4px 12px rgba(25,135,84,0.12);}
  button.ghost{background:transparent; color:var(--muted); border:1px dashed rgba(255,255,255,0.03);}
  button.warn{background:linear-gradient(90deg,#ffb4b4,var(--danger)); color:#2a1419;}
  .row{display:flex; gap:8px; align-items:center;}
  label{font-size:13px; color:var(--muted);}
  textarea{width:100%; min-height:140px; resize:vertical; background:transparent; color: #dffcf0; border:1px solid rgba(255,255,255,0.04); padding:10px; border-radius:8px;}
  .small-input{padding:8px; border-radius:8px; background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.03);}
  .two-videos{display:grid; grid-template-columns:1fr 1fr; gap:8px;}
  .meta{font-size:13px; color:var(--muted); margin-top:8px;}
  .pill{background:var(--glass); padding:6px 8px; border-radius:999px; font-size:13px; color:var(--muted);}
  .flex-between{display:flex; justify-content:space-between; align-items:center;}
  .chat{height:160px; overflow:auto; border-radius:8px; border:1px solid rgba(255,255,255,0.03); padding:8px; background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); color:#dffcf0;}
  .msg{padding:6px 8px; margin-bottom:6px; border-radius:6px; background:rgba(255,255,255,0.02);}
  footer{font-size:12px; color:var(--muted); margin-top:8px;}
  .muted{color:var(--muted)}
  .danger{color:var(--danger)}
  @media(max-width:900px){ .wrap{grid-template-columns:1fr; } .two-videos{grid-template-columns:1fr;} }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="left">
      <h1>WebRTC P2P Demo (No Backend)</h1>
      <p class="small">Manual signaling via SDP copy-paste. This demo waits for ICE gathering so SDP includes candidates (no trickle required).</p>

      <div class="two-videos">
        <div>
          <label class="muted">Local</label>
          <video id="localVideo" autoplay muted playsinline></video>
          <div class="controls" style="margin-top:8px;">
            <select id="cameraSelect" class="small-input"></select>
            <select id="micSelect" class="small-input"></select>
            <button id="startBtn">Start Camera</button>
          </div>
        </div>

        <div>
          <label class="muted">Remote</label>
          <video id="remoteVideo" autoplay playsinline></video>
          <div class="controls" style="margin-top:8px;">
            <button id="muteBtn" class="ghost">Mute</button>
            <button id="videoBtn" class="ghost">Stop Video</button>
            <button id="hangupBtn" class="warn">Hang Up</button>
          </div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="flex-between">
          <div class="pill" id="pcState">PC: Idle</div>
          <div class="pill" id="iceState">ICE: idle</div>
        </div>

        <div style="margin-top:10px;">
          <label class="muted">Local Actions</label>
          <div class="controls" style="margin-top:8px;">
            <button id="createOfferBtn">Create Offer & Gather ICE</button>
            <button id="createAnswerBtn">(If remote offer set) Create Answer</button>
          </div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <label class="muted">Remote SDP (Paste here)</label>
        <textarea id="remoteSDP" placeholder="Paste remote SDP (offer/answer) here..."></textarea>
        <div class="controls" style="margin-top:8px;">
          <button id="setRemoteBtn">Set Remote</button>
          <button id="copyLocalBtn" class="ghost">Copy Local SDP</button>
          <button id="clearBtn" class="ghost">Clear</button>
        </div>
      </div>

      <div style="margin-top:12px;">
        <label class="muted">Local SDP (read-only)</label>
        <textarea id="localSDP" readonly placeholder="Local SDP will appear here after creating offer/answer and ICE gathering."></textarea>
      </div>

      <footer>
        Tip: For cross-device: create offer on A ‚Üí paste to B ‚Üí create answer on B ‚Üí paste to A. If connection fails try reloading and repeating.
      </footer>
    </div>

    <div class="card">
      <h1>Data Channel Chat & Diagnostics</h1>
      <p class="small">Optional data channel for text chat + logs.</p>

      <div style="display:flex; gap:8px; align-items:center;">
        <button id="createDataChannelBtn">Open DataChannel</button>
        <div class="pill" id="dcState">DC: closed</div>
      </div>

      <div style="margin-top:10px;">
        <div class="chat" id="chatBox" aria-live="polite"></div>
        <div style="display:flex; gap:8px; margin-top:8px;">
          <input id="chatInput" class="small-input" placeholder="Type a message..." />
          <button id="sendBtn">Send</button>
        </div>
      </div>

      <div style="margin-top:12px;">
        <label class="muted">Event Log</label>
        <div class="chat" id="log" style="height:240px;"></div>
      </div>
    </div>
  </div>

<script>
(async function(){
  // Elements
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');
  const cameraSelect = document.getElementById('cameraSelect');
  const micSelect = document.getElementById('micSelect');
  const startBtn = document.getElementById('startBtn');
  const createOfferBtn = document.getElementById('createOfferBtn');
  const createAnswerBtn = document.getElementById('createAnswerBtn');
  const setRemoteBtn = document.getElementById('setRemoteBtn');
  const copyLocalBtn = document.getElementById('copyLocalBtn');
  const clearBtn = document.getElementById('clearBtn');
  const localSDP = document.getElementById('localSDP');
  const remoteSDP = document.getElementById('remoteSDP');
  const pcStateEl = document.getElementById('pcState');
  const iceStateEl = document.getElementById('iceState');
  const muteBtn = document.getElementById('muteBtn');
  const videoBtn = document.getElementById('videoBtn');
  const hangupBtn = document.getElementById('hangupBtn');
  const createDataChannelBtn = document.getElementById('createDataChannelBtn');
  const dcState = document.getElementById('dcState');
  const chatBox = document.getElementById('chatBox');
  const chatInput = document.getElementById('chatInput');
  const sendBtn = document.getElementById('sendBtn');
  const logEl = document.getElementById('log');

  let localStream = null;
  let pc = null;
  let dataChannel = null;
  let incomingDataChannel = null;
  let localAudioTrack = null;
  let localVideoTrack = null;

  function log(msg){
    const t = document.createElement('div');
    t.className = 'msg';
    t.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.prepend(t);
    console.debug(msg);
  }

  function appendChat(text, who='them'){
    const el = document.createElement('div');
    el.className = 'msg';
    el.textContent = (who==='me' ? 'Me: ' : 'Peer: ') + text;
    chatBox.appendChild(el);
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  // enumerate devices
  async function enumerateDevices() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      const mics = devices.filter(d => d.kind === 'audioinput');

      cameraSelect.innerHTML = cams.map(c => `<option value="${c.deviceId}">${c.label || 'Camera ' + (cams.indexOf(c)+1)}</option>`).join('');
      micSelect.innerHTML = mics.map(m => `<option value="${m.deviceId}">${m.label || 'Mic ' + (mics.indexOf(m)+1)}</option>`).join('');
    } catch (e) {
      log('Could not enumerate devices: ' + e);
    }
  }

  // start camera
  async function startCamera() {
    if (localStream) {
      // stop existing
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
      localVideo.srcObject = null;
    }
    const camId = cameraSelect.value || undefined;
    const micId = micSelect.value || undefined;

    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: camId ? { deviceId: { exact: camId } } : true,
        audio: micId ? { deviceId: { exact: micId } } : true
      });
      localVideo.srcObject = localStream;
      localAudioTrack = localStream.getAudioTracks()[0] || null;
      localVideoTrack = localStream.getVideoTracks()[0] || null;
      log('Local media started.');
    } catch (e) {
      log('getUserMedia error: ' + e);
      alert('Error accessing camera/microphone: ' + e.message);
    }
  }

  startBtn.addEventListener('click', async () => {
    await startCamera();
    await enumerateDevices(); // refresh labels
  });

  // Initialize device list early
  await enumerateDevices();

  // create RTCPeerConnection
  function createPeerConnection() {
    if (pc) return pc;
    // STUN servers optional ‚Äî still P2P without backend, but STUN helps NAT traversal.
    pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }
      ]
    });

    pc.oniceconnectionstatechange = () => {
      pcStateEl.textContent = 'PC: ' + (pc ? pc.iceConnectionState : 'closed');
      log('iceConnectionState: ' + pc.iceConnectionState);
    };
    pc.onconnectionstatechange = () => {
      pcStateEl.textContent = 'PC: ' + (pc ? pc.connectionState : 'closed');
      log('connectionState: ' + pc?.connectionState);
    };
    pc.onicegatheringstatechange = () => {
      iceStateEl.textContent = 'ICE: ' + pc.iceGatheringState;
      log('iceGatheringState: ' + pc.iceGatheringState);
    };

    pc.ontrack = (ev) => {
      // attach remote stream
      log('Received remote track(s).');
      try {
        remoteVideo.srcObject = ev.streams[0];
      } catch (e) {
        // fallback: build new stream
        const st = new MediaStream();
        ev.streams.forEach(s => s.getTracks().forEach(t => st.addTrack(t)));
        remoteVideo.srcObject = st;
      }
    };

    pc.ondatachannel = (ev) => {
      incomingDataChannel = ev.channel;
      dcState.textContent = 'DC: open (incoming)';
      setupDataChannel(incomingDataChannel, false);
      log('Incoming datachannel: ' + incomingDataChannel.label);
    };

    return pc;
  }

  function addLocalTracksToPC() {
    if (!pc) createPeerConnection();
    if (!localStream) return;
    localStream.getTracks().forEach(track => {
      try {
        pc.addTrack(track, localStream);
      } catch(e) {
        log('addTrack error: ' + e);
      }
    });
  }

  // Wait for ICE gathering to complete (so SDP contains candidates)
  function waitForIceGatheringComplete(pc) {
    return new Promise((resolve) => {
      if (pc.iceGatheringState === 'complete') {
        resolve();
      } else {
        function check(e){
          if (pc.iceGatheringState === 'complete') {
            pc.removeEventListener('icegatheringstatechange', check);
            resolve();
          }
        }
        pc.addEventListener('icegatheringstatechange', check);
      }
      // safety timeout
      setTimeout(() => {
        log('ICE gathering timeout, proceeding with available candidates.');
        resolve();
      }, 15000);
    });
  }

  async function createOffer() {
    try {
      createPeerConnection();
      addLocalTracksToPC();

      // optionally create data channel if user requested
      if (!dataChannel && createDataChannelBtn.dataset.requested === 'true') {
        createDataChannel();
      }

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      log('Local description set (offer). Waiting for ICE.');
      await waitForIceGatheringComplete(pc);
      localSDP.value = JSON.stringify(pc.localDescription);
      navigator.clipboard?.writeText(localSDP.value).catch(()=>{});
      log('Offer created and copied to clipboard (if allowed).');
    } catch (e) {
      log('createOffer error: ' + e);
    }
  }

  async function createAnswer() {
    try {
      if (!pc) createPeerConnection();
      addLocalTracksToPC();
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      log('Local description set (answer). Waiting for ICE.');
      await waitForIceGatheringComplete(pc);
      localSDP.value = JSON.stringify(pc.localDescription);
      navigator.clipboard?.writeText(localSDP.value).catch(()=>{});
      log('Answer created and copied to clipboard (if allowed).');
    } catch (e) {
      log('createAnswer error: ' + e);
    }
  }

  // set remote description from pasted text
  async function setRemoteFromText() {
    const text = remoteSDP.value.trim();
    if (!text) { alert('Paste remote SDP JSON into the Remote SDP box.'); return; }
    let obj;
    try {
      obj = JSON.parse(text);
    } catch (e) {
      alert('Invalid JSON. Make sure you pasted the exact JSON produced by the other peer.');
      return;
    }
    try {
      if (!pc) createPeerConnection();
      await pc.setRemoteDescription(obj);
      log('Remote description applied.');
    } catch (e) {
      log('setRemoteDescription error: ' + e);
      alert('Error setting remote description: ' + e.message);
    }
  }

  // copy local SDP button
  copyLocalBtn.addEventListener('click', () => {
    if (!localSDP.value) { alert('Local SDP is empty. Create offer/answer first.'); return; }
    navigator.clipboard.writeText(localSDP.value).then(()=> {
      alert('Local SDP copied to clipboard.');
    }).catch(()=> {
      alert('Copy to clipboard failed ‚Äî select and copy manually.');
    });
  });

  // UI buttons
  createOfferBtn.addEventListener('click', async () => {
    await createOffer();
  });

  createAnswerBtn.addEventListener('click', async () => {
    // Use this only after you've set a remote offer
    await createAnswer();
  });

  setRemoteBtn.addEventListener('click', async () => {
    await setRemoteFromText();
  });

  clearBtn.addEventListener('click', () => {
    remoteSDP.value = '';
    localSDP.value = '';
  });

  hangupBtn.addEventListener('click', () => {
    if (pc) {
      pc.getSenders().forEach(s => { try { if (s.track) s.track.stop(); } catch(e){} });
      pc.close();
      pc = null;
    }
    if (localStream) {
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;
    }
    dataChannel = null;
    incomingDataChannel = null;
    dcState.textContent = 'DC: closed';
    pcStateEl.textContent = 'PC: Idle';
    iceStateEl.textContent = 'ICE: idle';
    log('Hung up and released media/peerconnection.');
  });

  // mute / video toggle
  muteBtn.addEventListener('click', () => {
    if (!localAudioTrack) return;
    localAudioTrack.enabled = !localAudioTrack.enabled;
    muteBtn.textContent = localAudioTrack.enabled ? 'Mute' : 'Unmute';
    log('Audio ' + (localAudioTrack.enabled ? 'enabled' : 'muted'));
  });

  videoBtn.addEventListener('click', () => {
    if (!localVideoTrack) return;
    localVideoTrack.enabled = !localVideoTrack.enabled;
    videoBtn.textContent = localVideoTrack.enabled ? 'Stop Video' : 'Start Video';
    log('Video ' + (localVideoTrack.enabled ? 'enabled' : 'disabled'));
  });

  // DataChannel helpers
  function setupDataChannel(dc, isLocal) {
    dc.onopen = () => {
      dcState.textContent = 'DC: open';
      log('DataChannel open: ' + dc.label);
    };
    dc.onclose = () => {
      dcState.textContent = 'DC: closed';
      log('DataChannel closed: ' + dc.label);
    };
    dc.onmessage = (ev) => {
      appendChat(ev.data, 'them');
      log('DataChannel message received.');
    };
    dc.onerror = (e) => {
      log('DataChannel error: ' + e);
    };
  }

  function createDataChannel() {
    if (!pc) createPeerConnection();
    try {
      dataChannel = pc.createDataChannel('chat');
      setupDataChannel(dataChannel, true);
      createDataChannelBtn.dataset.requested = 'true';
      dcState.textContent = 'DC: created';
      log('DataChannel created locally.');
    } catch (e) {
      log('createDataChannel error: ' + e);
    }
  }

  createDataChannelBtn.addEventListener('click', () => {
    createDataChannel();
  });

  sendBtn.addEventListener('click', () => {
    const text = chatInput.value.trim();
    if (!text) return;
    if (dataChannel && dataChannel.readyState === 'open') {
      dataChannel.send(text);
      appendChat(text, 'me');
      chatInput.value = '';
      log('Sent via dataChannel.');
    } else if (incomingDataChannel && incomingDataChannel.readyState === 'open') {
      incomingDataChannel.send(text);
      appendChat(text, 'me');
      chatInput.value = '';
      log('Sent via incoming dataChannel.');
    } else {
      alert('No open data channel. Create one and ensure peers exchange offer/answer.');
    }
  });

  // handle device change updates
  navigator.mediaDevices.addEventListener('devicechange', () => {
    enumerateDevices();
    log('Device list changed.');
  });

  // when remote tracks stop, clear remote video
  remoteVideo.addEventListener('pause', () => {
    // nothing, but can be used
  });

  // load sample usage log
  log('Demo loaded. Start camera and follow manual SDP exchange steps.');
})();
</script>
</body>
</html>            </div>

            <!-- Active Call Controls -->
            <div id="active-call-ui" style="display:none; background:#2e7d32; padding:15px; border-radius:10px; margin-bottom:15px;">
                <p>Baat chal rahi hai... üéôÔ∏è</p>
                <button class="btn-end" style="display:block;" onclick="endCall()">‚ùå Call Kato</button>
            </div>

            <!-- Online Users List -->
            <p style="text-align: left; color: #888; margin-bottom: 5px;">Online Dosto ki List:</p>
            <ul class="user-list" id="user-list">
                <!-- Users yahan aayenge automatically -->
                <li style="color: #555; font-style: italic; padding: 10px;">Scanning for friends...</li>
            </ul>
        </div>
    </div>

    <!-- Hidden Audio -->
    <audio id="remote-audio" autoplay></audio>

    <script>
        // === CONFIGURATION ===
        const APP_NAME = 'desi_call_v1_simple'; // Unique Room Name
        
        // Global Variables
        let myPeerId = null;
        let myName = "";
        let peer = null;
        let currentCall = null;
        let incomingCallRef = null;
        
        // Initialize GunDB (Free Decentralized Database)
        const gun = Gun(['https://gun-manhattan.herokuapp.com/gun']);

        // 1. JOIN APP FUNCTION
        function joinApp() {
            const nameInput = document.getElementById('username').value;
            if(!nameInput) return alert("Naam likhna zaruri hai!");
            
            myName = nameInput;
            
            // Generate Random ID like Phone Number
            myPeerId = Math.floor(100000 + Math.random() * 900000).toString();
            
            // UI Update
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('app-screen').style.display = 'block';
            document.getElementById('my-name-display').innerText = myName + " (You)";

            initPeer();
        }

        // 2. PEERJS SETUP (Calling System)
        function initPeer() {
            peer = new Peer(myPeerId);

            peer.on('open', (id) => {
                document.getElementById('connection-status').innerText = "Online ‚úÖ";
                
                // GunDB me khud ko register karo
                const userRef = gun.get(APP_NAME).get('users');
                userRef.get(id).put({ 
                    name: myName, 
                    id: id, 
                    lastSeen: Date.now() 
                });

                // Har 5 second me heartbeat bhejo taaki online dikhein
                setInterval(() => {
                    userRef.get(id).put({ name: myName, id: id, lastSeen: Date.now() });
                }, 5000);

                startListeningForUsers();
            });

            // Incoming Call
            peer.on('call', (call) => {
                incomingCallRef = call;
                // Call karne wale ka naam ID se nahi pata chalega directly is simple logic me, 
                // isliye hum generic message dikhayenge ya metadata use karenge.
                document.getElementById('caller-name').innerText = "Koi Dost"; 
                document.getElementById('incoming-call-alert').style.display = 'block';
            });
        }

        // 3. USER LIST LISTENER (Phonebook)
        function startListeningForUsers() {
            const listElement = document.getElementById('user-list');
            const usersFound = {}; // Duplicate hatane ke liye

            gun.get(APP_NAME).get('users').map().on((data, id) => {
                if(!data || !data.id || data.id === myPeerId) return; // Khud ko list me mat dikhao

                // Check if user is recently active (within last 20 seconds)
                // Note: Real world me ye thoda complex hota hai, ye basic filter hai.
                const now = Date.now();
                if(now - data.lastSeen > 60000) {
                    // Agar 1 min se purana hai to ignore karo (Old user)
                    return; 
                }

                usersFound[id] = data;
                renderUserList(usersFound);
            });
        }

        function renderUserList(users) {
            const listElement = document.getElementById('user-list');
            listElement.innerHTML = '';

            Object.values(users).forEach(user => {
                const li = document.createElement('li');
                li.className = 'user-item';
                li.innerHTML = `
                    <span class="user-name">üë§ ${user.name}</span>
                    <button class="btn-call-mini" onclick="makeCall('${user.id}')">üìû Call</button>
                `;
                listElement.appendChild(li);
            });

            if(Object.keys(users).length === 0) {
                listElement.innerHTML = '<li style="padding:10px; color:#666;">Koi online nahi hai...</li>';
            }
        }

        // 4. CALL HANDLING
        function acceptCall() {
            document.getElementById('incoming-call-alert').style.display = 'none';
            
            navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then((stream) => {
                incomingCallRef.answer(stream);
                handleStream(incomingCallRef);
            }).catch(err => alert("Mic Permission Denied"));
        }

        function makeCall(remoteId) {
            if(currentCall) return alert("Already call par hain!");
            
            navigator.mediaDevices.getUserMedia({ video: false, audio: true }).then((stream) => {
                const call = peer.call(remoteId, stream);
                handleStream(call);
            }).catch(err => alert("Mic Permission check karein"));
        }

        function handleStream(call) {
            currentCall = call;
            document.getElementById('active-call-ui').style.display = 'block';
            document.getElementById('user-list').style.opacity = '0.5'; // List ko dhundhla kar do

            call.on('stream', (remoteStream) => {
                document.getElementById('remote-audio').srcObject = remoteStream;
            });

            call.on('close', endCallUI);
            call.on('error', () => { alert("Connection Error"); endCallUI(); });
        }

        function endCall() {
            if(currentCall) currentCall.close();
            endCallUI();
        }

        function endCallUI() {
            currentCall = null;
            document.getElementById('active-call-ui').style.display = 'none';
            document.getElementById('incoming-call-alert').style.display = 'none';
            document.getElementById('user-list').style.opacity = '1';
        }
    </script>
</body>
</html>
